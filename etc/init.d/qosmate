#!/bin/sh /etc/rc.common
# shellcheck disable=SC2034,SC3043,SC1091,SC2155,SC3020,SC3010,SC2016,SC3060

START=99
STOP=99

USE_PROCD=1

VERSION="dev"
UPD_CHANNEL="release"

EXTRA_COMMANDS="check_version update auto_setup expand_config auto_setup_noninteractive validate_custom_rules health_check sync_timestamps"
EXTRA_HELP="
        check_version              Check for updates
        update                     Update qosmate
        auto_setup                 Automatically configure qosmate
        expand_config              Expand the configuration with all possible options
        auto_setup_noninteractive  Automatically configure qosmate with no interaction
        validate_custom_rules      Validate custom rules
        health_check               Check if QoSmate is properly configured and running
        sync_timestamps            If you manually edited some files, use this command to silence the warning"

REQUIRED_PACKAGES="kmod-sched ip-full kmod-veth tc-full kmod-netem kmod-sched-ctinfo kmod-ifb kmod-sched-cake kmod-sched-red luci-lib-jsonc lua jq"

### repo-related vars

# GH repo author (can be overriden for testing)
: "${QOSMATE_REPO_AUTHOR:=hudra0}"

MAIN_BRANCH_BACKEND=main
MAIN_BRANCH_FRONTEND=main

# Base URL (raw) for repositories (can be overridden for different branches/commits)
QOSMATE_BASE_URL="${QOSMATE_BASE_URL:-https://raw.githubusercontent.com/${QOSMATE_REPO_AUTHOR}/qosmate/${MAIN_BRANCH_BACKEND}}"

# Base GH API URLs for repositories (can be overridden)
: "${QOSMATE_AUTHOR_GH_API_URL:="https://api.github.com/repos/${QOSMATE_REPO_AUTHOR}"}"
: "${QOSMATE_GH_API_URL_BACKEND:="${QOSMATE_AUTHOR_GH_API_URL}/qosmate"}"
: "${QOSMATE_GH_API_URL_FRONTEND:="${QOSMATE_AUTHOR_GH_API_URL}/luci-app-qosmate"}"

QOSMATE_UPD_DIR=/var/run/qosmate-update


### Utility vars
_DELIM_="$(printf '\35')"
_NL_='
'
DEFAULT_IFS=" 	${_NL_}"
IFS="$DEFAULT_IFS"


### Components
QOSMATE_COMPONENTS="BACKEND FRONTEND"


### Backend files
QOSMATE_SERVICE_PATH=/etc/init.d/qosmate

# stores the version, update channel, and sets the reference timestamp
QOSMATE_MAIN_FILE_BACKEND=$QOSMATE_SERVICE_PATH

QOSMATE_FILE_TYPES_BACKEND="GEN EXTRA" # change the value if adding more types
QOSMATE_GEN_FILES_BACKEND=" \
	$QOSMATE_SERVICE_PATH \
	/etc/qosmate.sh \
	/usr/lib/tc/experimental.dist \
	/usr/lib/tc/normal.dist \
	/usr/lib/tc/normmix20-64.dist \
	/usr/lib/tc/pareto.dist \
	/usr/lib/tc/paretonormal.dist"
QOSMATE_EXEC_FILES_BACKEND=" \
	$QOSMATE_SERVICE_PATH \
	/etc/qosmate.sh"
QOSMATE_EXTRA_FILES_BACKEND="" # might be useful in the future?


### Frontend files
QOSMATE_FRONTEND_DIR_JS=/www/luci-static/resources/view/qosmate

# stores the version, update channel, and sets the reference timestamp
QOSMATE_MAIN_FILE_FRONTEND="${QOSMATE_FRONTEND_DIR_JS}/settings.js" 

QOSMATE_FILE_TYPES_FRONTEND="GEN EXTRA JS" # change the value if adding more types
QOSMATE_GEN_FILES_FRONTEND=" \
	/usr/share/luci/menu.d/luci-app-qosmate.json \
	/usr/share/rpcd/acl.d/luci-app-qosmate.json \
	/usr/libexec/rpcd/luci.qosmate \
	/usr/libexec/rpcd/luci.qosmate_stats"
QOSMATE_EXTRA_FILES_FRONTEND="" # might be useful in the future?

QOSMATE_JS_FILENAMES=" \
	settings.js \
	hfsc.js \
	cake.js \
	advanced.js \
	rules.js \
	connections.js \
	custom_rules.js \
	ipsets.js \
	statistics.js"
# generate js file list with paths
QOSMATE_JS_FILES_FRONTEND=
for js_file in ${QOSMATE_JS_FILENAMES}; do
	QOSMATE_JS_FILES_FRONTEND="${QOSMATE_JS_FILES_FRONTEND}${QOSMATE_FRONTEND_DIR_JS}/${js_file} "
done

QOSMATE_EXEC_FILES_FRONTEND=" \
	/usr/libexec/rpcd/luci.qosmate \
	/usr/libexec/rpcd/luci.qosmate_stats"


### Utility functions

# 1 - string
# 2 - path to file
write_str_to_file() {
	printf '%s\n' "$1" > "$2" || { error_out "Failed to write to file '$2'."; return 1; }
	:
}

# 0 - (optional) '-p'
# 1 - path
try_mkdir() {
	local p=
	[ "$1" = '-p' ] && { p='-p'; shift; }
	[ -d "$1" ] && return 0
	mkdir ${p} "$1" || { error_out "Failed to create directory '$1'."; return 1; }
	:
}

check_util() { command -v "$1" 1>/dev/null; }

error_out() { log_msg -err "${@}"; }

# logs each message argument separately and prints to a separate line
# optional arguments: '-err', '-warn' to set logged error level
log_msg() {
	local msgs_prefix='' _arg err_l=info msgs_dest

	local IFS="$DEFAULT_IFS"
	for _arg in "$@"
	do
		case "${_arg}" in
			"-err") err_l=err msgs_prefix="Error: " ;;
			"-warn") err_l=warn msgs_prefix="Warning: " ;;
			'') printf '\n' ;; # print out empty lines
			*)
				case "$err_l" in
					err|warn) msgs_dest="/dev/stderr" ;;
					*) msgs_dest="/dev/stdout"
				esac
				printf '%s\n' "${msgs_prefix}${_arg}" > "$msgs_dest"
				logger -t qosmate -p user."$err_l" "${msgs_prefix}${_arg}"
				msgs_prefix=''
		esac
	done
	:
}

# check if var names are safe to use with eval
are_var_names_safe() {
	local var_name
	for var_name in "$@"; do
		case "$var_name" in *[!a-zA-Z_]*) error_out "Invalid var name '$var_name'."; return 1; esac
	done
	:
}

# 1 - path to file
get_file_timestamp() {
	[ -f "$1" ] || { error_out "get_file_timestamp: file '$1' not found."; return 1; }
	ls --full-time "$1" |
	awk '
		BEGIN{rv=1}
		match($0,/[0-9]{4}-[0-9]{2}-[0-9]{2}[ \t]+[0-9]{2}:[0-9]{2}:[0-9]{2}/) {
			print substr($0,RSTART,RLENGTH)
			rv=0
			exit
		}
		END{exit rv}
	' || {
			error_out "" "Failed to get timestamp of file '$1'."
			return 1
		}
	:
}

# 1 - component: <BACKEND|FRONTEND>
# 2 - paths to files
# Error codes:
# 1 - general error
# 2 - missing files
# 3 - non-match detected or fail to get timestamp
# otherwise return 0
verify_timestamps() {
	local file component="$1" no_match_files='' main_file_path me=verify_timestamps
	[ -n "$1" ] && [ -n "$2" ] || { error_out "$me: missing args."; return 1; }

	for file in $2; do
		[ -f "$file" ] || { error_out "$me: file '$file' is missing."; return 1; }
	done

	eval "main_file_path=\"\${QOSMATE_MAIN_FILE_${component}}\""
	main_timestamp="$(get_file_timestamp "$main_file_path")" || return 1

	no_match_files="$(
		ls --full-time $2 |
		awk -v R="$main_timestamp" '
			BEGIN{rv=0}
			{
				if ($0~/^[-rwx]{10}[ \t]/)
				{
					if ( match($0,/[0-9]{4}-[0-9]{2}-[0-9]{2}[ \t]+[0-9]{2}:[0-9]{2}:[0-9]{2}/) ) {
							t=substr($0,RSTART,RLENGTH)
							if (R==t) {next}
							else {no_match=no_match $NF " "; rv=1}
					}
					else {no_match=no_match $NF " "; rv=1}
				}
				else {next}
			}
			END{if (no_match) {print no_match}; exit rv}
		'
	)" || {
		log_msg -warn "" "Timestamp of files '$no_match_files' doesn't match timestamp of the main $component file '$main_file_path'." \
			"Warning: Possible QoSmate installation integrity problem." \
			"If you manually edited the file(s), run 'service qosmate sync_timestamps $component' to silence the warning." ""
		return 3
	}
}

### Update-related functions

# 1 - component: <BACKEND|FRONTEND>
# return codes:
# 0 - OK
# 1 - general error
# 2 - missing files
# 3 - non-matching timestamps
check_files_integrity() {
	local file files file_types component main_timestamp cf_rv=0 component="$1"

	files=
	eval "file_types=\"\${QOSMATE_FILE_TYPES_${component}}\""

	get_file_list files "$component" ALL && [ -n "$files" ] ||
		{ error_out "Failed to get file list for component '$component'."; return 1; }
	
	for file in $files; do
		[ -f "$file" ] || { error_out "Missing file: '$file'."; return 2; }
	done

	verify_timestamps "$component" "$files" ||
	case $? in
		2) return 2 ;;
		3) cf_rv=3 ;;
		*) return 1
	esac
	return $cf_rv
}

# When updating, old version of the script should call this function from the new version via
#   'sh <qosmate_init_preinst_path> print_file_list <BACKEND|FRONTEND> <ALL|"[types]"">'
# 1 - BACKEND|FRONTEND
# 2 - types: 'ALL' (doesn't print executable files) or any combination (space-separated) of 'GEN', 'EXTRA', 'JS', 'EXEC'
print_file_list() {
	[ -n "$1" ] && [ -n "$2" ] || { error_out "print_file_list: missing args."; return 1; }
	local files='' component="$1"
	shift
	get_file_list files "$component" "$*" || return 1
	printf '%s\n' "$files"
	:
}

# 1 - var name for output
# 2 - BACKEND|FRONTEND
# 3 - types: 'ALL' (doesn't print executable files) or any combination (space-separated) of 'GEN', 'EXTRA', 'JS', 'EXEC'
get_file_list() {
	local me=get_file_list gf_out_var="$1" component="$2" file_types="$3" file_type gf_files=''

	[ -n "$1" ] && [ -n "$2" ] && [ -n "$3" ] || { error_out "$me: missing args."; return 1; }
	are_var_names_safe "$1" || return 1

	eval "$gf_out_var="

	case "$component" in
		BACKEND|FRONTEND) ;;
		*) error_out "$me: invalid component '$component'."; return 1
	esac

	if [ "$file_types" = ALL ]; then
		eval "file_types=\"\${QOSMATE_FILE_TYPES_${component}}\""
	fi

	for file_type in ${file_types}; do
		case "$file_type" in
			GEN|EXTRA|JS|EXEC)
				eval "gf_files=\"${gf_files}\${QOSMATE_${file_type}_FILES_${component}} \"" ;;
			*) error_out "$me: invalid type '$file_type'"; return 1
		esac
	done

	# remove extra whitespaces, tabs, newlines
	local IFS="$DEFAULT_IFS"
	set -- $gf_files
	eval "$gf_out_var"='$*'
	:
}

# When updating, old version of the script should call post_update_[X] functions from the new version
#   post_update_1 should be called via '/bin/sh <qosmate_init_preinst_path> post_update_1' *before* new version is installed
#   post_update_2 should be called via '/bin/sh "$QOSMATE_SERVICE_PATH" post_update_2' *after* new version is installed
# This allows flexibility when adding new features etc.
post_update_1() {
	:
	# <do something...>
	return $?
}

post_update_2() {
	# <do something...>
    expand_config
	return $?
}

# Fetches qosmate distribution for specified component
# assigns path to extracted distribution directory to $1
# 1 - component (BACKEND|FRONTEND)
# 2 - tarball url
# 3 - github ref
fetch_qosmate_component() {
	local arg repo_name me=fetch_qosmate_component
	for arg in 1 2 3; do
		eval "[ -z \"\${$arg}\" ]" && { error_out "$me: missing argument $arg."; return 1; }
	done

	local fetch_tarball_url="$2" component="$1" upd_dir extract_dir fetch_rv
	local upd_dir="${QOSMATE_UPD_DIR}/${component}"
	local tarball="${upd_dir}/remote_qosmate.tar.gz" ucl_err_file="${upd_dir}/ucl_err"

	case "$component" in
		BACKEND) repo_name=qosmate ;;
		FRONTEND) repo_name=luci-app-qosmate ;;
		*) error_out "$me: invalid component '$component'."; return 1
	esac

	rm -f "$ucl_err_file" "${tarball}"
	rm -rf "${upd_dir}/${QOSMATE_REPO_AUTHOR}-${repo_name}-"*
	try_mkdir -p "$upd_dir" || return 1

	uclient-fetch "$fetch_tarball_url" -O "${tarball}" 2> "$ucl_err_file" &&
	grep -q "Download completed" "$ucl_err_file" &&
	tar -C "${upd_dir}" -xzf "${tarball}" &&
	extract_dir="$(find "${upd_dir}/" -type d -name "${QOSMATE_REPO_AUTHOR}-${repo_name}-*")" &&
		[ -n "$extract_dir" ] && [ "$extract_dir" != "/" ]
	fetch_rv=${?}
	rm -f "${tarball}"

	[ "$fetch_rv" != 0 ] && [ -s "$ucl_err_file" ] && ! grep -q "Download completed" "$ucl_err_file" &&
		error_out "uclient-fetch errors: '$(cat "$ucl_err_file")'."
	rm -f "$ucl_err_file"

	[ "$fetch_rv" = 0 ] && {
		mv "${extract_dir:-?}"/* "${upd_dir:-?}/" || { rm -rf "${extract_dir:-?}"; error_out "Failed to move files to dist dir."; return 1; }
	}
	rm -rf "${extract_dir:-?}"

	return $fetch_rv
}

# Get GitHub ref and tarball url for specified component, update channel, branch and version
# 1 - component (BACKEND|FRONTEND)
# 2 - update channel: release|snapshot|branch=<github_branch>|commit
# 3 - version (irrelevant to upd. channel 'branch'): <qosmate_version>|<commit_hash>
# Output via variables:
#   $4 - github ref, $5 - tarball url
get_gh_ref_data() {
	local me=get_gh_ref_data ref_fetch_url jsonfilter_ptrn commit main_branch \
		gh_ref='' gh_url_api ref_fetch_tmp_dir="/tmp/qosmate-gh" ref_fetch_rv=0 \
		component="$1" gh_channel="$2" version="$3"

	local ref_ucl_err_file="${ref_fetch_tmp_dir}/ucl_err"

	are_var_names_safe "$4" "$5" || return 1
	eval "$4='' $5='' gh_url_api=\"\${QOSMATE_GH_API_URL_${component}}\""

	eval "main_branch=\"\${MAIN_BRANCH_${component}}\""

	case "$gh_channel" in
		release)
			if [ -n "$version" ]; then
				gh_ref="v${version}"
			else
				ref_fetch_url="${gh_url_api}/releases"
				jsonfilter_ptrn='@[@.prerelease=false]' # ignore pre-releases
			fi ;;
		snapshot)
			if [ -n "$version" ]; then
				gh_ref="${version}"
			else
				ref_fetch_url="${gh_url_api}/commits/${main_branch}"
				jsonfilter_ptrn='@.sha' # latest commit is first on the list
			fi ;;
		branch=*)
				ref_fetch_url="${gh_url_api}/commits/${gh_channel##*=}"
				jsonfilter_ptrn='@.sha' ;; # latest commit is first on the list
		commit)
			commit="${version}"
			gh_ref="${commit%"${commit#???????}"}" ;; # trim commit hash to 7 characters
		*)
			error_out "${me}: invalid update channel '$gh_channel'."
			return 1
	esac

	if [ -n "$ref_fetch_url" ]
	then
		try_mkdir -p "$ref_fetch_tmp_dir" || return 1
		# Get ref for release/snapshot
		gh_ref="$(
			uclient-fetch "$ref_fetch_url" -O- 2> "$ref_ucl_err_file" |
			jsonfilter -e "$jsonfilter_ptrn" |
			{
				case "$gh_channel" in
					snapshot|branch=*)
						head -c7 # trim commit hash to 7 characters
						;;
					release)
						# get latest tag for ${main_branch}
						jsonfilter -a -e "@[@.target_commitish=\"${main_branch}\"].tag_name" | head -n1
						;;
				esac
				cat 1>/dev/null
			}
		)"
		if [ -f "$ref_ucl_err_file" ] && ! grep -q "Download completed" "$ref_ucl_err_file"; then
			error_out "${me}: Failed to fetch GitHub ref.${_NL_}uclient-fetch log:${_NL_}$(cat "$ref_ucl_err_file")"
			log_msg "ref fetch command: 'uclient-fetch \"$ref_fetch_url\" -O-'"
			ref_fetch_rv=1
		fi
		rm -rf "${ref_fetch_tmp_dir:-?}"
		[ "$ref_fetch_rv" = 0 ] || return 1
	fi

	# validate resulting ref
	case "$gh_ref" in
		''|*[!a-zA-Z0-9._-]*)
			error_out "${me}: failed to get GitHub ref for $gh_channel '$version'."
			return 1
	esac

	eval "$4"='$gh_ref' "$5"='${gh_url_api}/tarball/${gh_ref}'

	:
}

# optional: '-s <path>' to simulate update (intended for testing: service qosmate update -s <path_to_new_ver> -v <version>)
# optional: '-c <frontend|backend>' to only update specified component
# optional: -v [<version>|package[=<version>]|release[=version]|snapshot[=version]|branch=<branch>|commit=<commit_hash>]
# optional: '-n' to skip restarting the service
update() {
	upd_failed() {
		rm -rf "${QOSMATE_UPD_DIR:-?}"
		[ -n "$*" ] && error_out "$@"
		error_out "Failed to update QoSmate."
	}

	pkg_update_not_impl() {
		upd_failed "Update channel 'package' not implemented."
	}

	unexp_arg() { upd_failed "update: unexpected argument '$1'."; }

	local file origin new_file_list exec_files sim_path='' version='' ver_str_arg='' def_ver_str='' \
		extract_dir='' norestart='' dist_dir='' ref='' tarball_url='' file_list_query_path \
		backend_upd_req='' multi_upd_req='' upd_component='' upd_components='' \
		req_upd_channel upd_channel='' def_upd_channel='' def_upd_channel_BACKEND='' def_upd_channel_FRONTEND=''

	while getopts ":s:v:c:n" opt; do
		case ${opt} in
			c) upd_component=$OPTARG ;;
			s) sim_path=$OPTARG ;;
			v) ver_str_arg=$OPTARG ;;
			n) norestart=1 ;;
			*) unexp_arg "$OPTARG"; return 1
		esac
	done
	shift $((OPTIND-1))
	[ -z "${*}" ] || { unexp_arg "${*}"; return 1; }

	case "$upd_component" in
		'') ;;
		backend|BACKEND) upd_component=BACKEND ;;
		frontend|FRONTEND) upd_component=FRONTEND ;;
		*) upd_failed "Unexpected component '$upd_component'"; return 1
	esac
	upd_components="${upd_component:-"$QOSMATE_COMPONENTS"}"

	log_msg "Updating QoSmate components '$upd_components'..."

	# parse version string from arguments into $req_upd_channel, $version
	case "$ver_str_arg" in
		'') ;;
		package*)
			pkg_update_not_impl
			return 1 ;;
		release|snapshot)
			req_upd_channel="${ver_str_arg}" version='' ;;
		snapshot=*)
			req_upd_channel="${ver_str_arg%%=*}" version="${ver_str_arg#*=}" ;;
		commit=*)
			req_upd_channel="${ver_str_arg%%=*}" version="${ver_str_arg#*=}" ;;
		branch=*)
			req_upd_channel="$ver_str_arg" version='' ;;
		[0-9]*|v[0-9]*|release=[0-9]*|release=v[0-9]*)
			req_upd_channel=release
			version="${ver_str_arg#*=}"
			version="${version#v}" ;;
		*)
			upd_failed "Invalid version string '$ver_str_arg'."
			return 1
	esac

	rm -rf "${QOSMATE_UPD_DIR:-?}"
	try_mkdir -p "$QOSMATE_UPD_DIR" || { upd_failed; return 1; }

	if [ -n "$sim_path" ]
	then
		log_msg "Updating in simulation mode."
		[ -d "$sim_path" ] || { upd_failed "Update simulation directory '$sim_path' does not exist."; return 1; }
		[ -n "$ver_str_arg" ] || { upd_failed "Specify new version string."; return 1; }
		def_upd_channel=release
		ref="$ver_str_arg"
		: "${req_upd_channel:="${def_upd_channel}"}"

		for component in $upd_components; do
			[ -d "${sim_path}/${component}" ] ||
				{ upd_failed "Simulation source directory doesn't have ${component} directory"; return 1; }
		done
		cp -rT "$sim_path" "$QOSMATE_UPD_DIR"
	fi

	case "$upd_components" in *BACKEND*)
		backend_upd_req=1
	esac

	for component in $upd_components; do
		upd_channel=
		# set default update channel
		case "$component" in
			BACKEND)
				def_upd_channel="${UPD_CHANNEL:-release}" ;;
			FRONTEND)
				if [ -n "$req_upd_channel" ]; then
					:
				elif [ ! -f "$QOSMATE_MAIN_FILE_FRONTEND" ]; then
					def_upd_channel=release
				else
					local pattern="^const UI_UPD_CHANNEL"
					# assumes version string enclosed in ' and no prior ' present in the version line
					def_upd_channel="$(
						awk -F "'" "
							BEGIN{rv=1}
							\$0~/$pattern/ {
								rv=2
								print \$2
								if (\$2~/^[ 	]*(branch[ 	]*=[ 	]*){0,1}[-a-zA-Z0-9_]/ ) {rv=0}
								exit
							}
							END{exit rv}" "$QOSMATE_MAIN_FILE_FRONTEND"
					)" || {
						log_msg -err "Failed to get current FRONTEND update channel. Defaulting to 'release'."
						def_upd_channel=release
					}
				fi
		esac

		upd_channel="${req_upd_channel:-"${def_upd_channel}"}"

		dist_dir="${QOSMATE_UPD_DIR}/${component}"
		case "$upd_channel" in
			package)
				pkg_update_not_impl
				return 1 ;;
			*)
				if [ -n "$sim_path" ]
				then
					log_msg "" "Updating $component to version '$ref' (update channel: '$upd_channel')."
				else
					get_gh_ref_data "$component" "$upd_channel" "$version" ref tarball_url || return 1
					log_msg "" "Downloading $component, version '$ref' (update channel: '$upd_channel')."
					fetch_qosmate_component "$component" "$tarball_url" "$ref" || { upd_failed; return 1; }
				fi

				if [ -n "$backend_upd_req" ]; then
					file_list_query_path="${QOSMATE_UPD_DIR}/BACKEND${QOSMATE_SERVICE_PATH}"
				else
					file_list_query_path="${QOSMATE_SERVICE_PATH}"
				fi

				new_file_list="$(/bin/sh "$file_list_query_path" print_file_list "$component" ALL)" &&
				write_str_to_file "$new_file_list" "${dist_dir}/new_file_list" &&
				[ -n "$new_file_list" ] || {
					upd_failed "Failed to get file list from the fetched QoSmate version." \
						"NOTE: QoSmate versions prior to v1.2.0 do not support the new update mechanism."
					return 1
				}

				exec_files="$(/bin/sh "$file_list_query_path" print_file_list "$component" "EXEC")" &&
				write_str_to_file "$exec_files" "${dist_dir}/exec_files" || { upd_failed; return 1; }
				eval "ref_${component}"='$ref'
		esac
	done

	[ -n "$backend_upd_req" ] &&
		/bin/sh "${QOSMATE_UPD_DIR}/BACKEND${QOSMATE_SERVICE_PATH}" post_update_1

	case "$ver_str_arg" in
		package*)
			pkg_update_not_impl
			return 1 ;;
		*)
			install_qosmate_files "$QOSMATE_UPD_DIR" "$upd_components" "$upd_channel" || { upd_failed; return 1; }
			rm -rf "${QOSMATE_UPD_DIR:-?}"
	esac

	[ -n "$backend_upd_req" ] && chmod +x "$QOSMATE_SERVICE_PATH"
	/bin/sh "$QOSMATE_SERVICE_PATH" post_update_2 # post_update_2 is called when updating either component

	log_msg "QoSmate components '$upd_components' have been successfully updated."

	if [ -n "$backend_upd_req" ] && "$QOSMATE_SERVICE_PATH" enabled; then
		log_msg "" "Restarting QoSmate."
    	${QOSMATE_SERVICE_PATH} restart
	fi
	:
}

# 1 - path to upper distribution dir (containing a dir for each component)
# 2 - component(s): <BACKEND|FRONTEND|"BACKEND FRONTEND">
# 3 - update channel
install_qosmate_files() {
	inst_failed() {
		[ -n "$1" ] && error_out "$1"
		error_out "install_qosmate_files: Failed to install new $component files."
	}

	# frontend path fixups
	# 1 - var name to output fixed up path
	# 2 - dist dir
	# 3 - destination file path
	fixup_frontend_path() {
		are_var_names_safe "$1" || return 1
		eval "$1="
		local fixup_preinst_dir fixup_filename fixup_prinst_dir fixup_preinst_path
		case "$3" in
			/usr/*) fixup_preinst_path="${2}/root${3}" ;;
			/www/*)
				fixup_preinst_path="${2}/htdocs${3#/www}"
				fixup_filename="${fixup_preinst_path##*/}"
				fixup_preinst_dir="${fixup_preinst_path%"$fixup_filename"}"
				fixup_preinst_path="${fixup_preinst_dir%"qosmate/"}${fixup_filename}" ;;
			*) fixup_preinst_path="${2}${file}"
		esac
		eval "$1"='$fixup_preinst_path'
	}

	local file prefix preinst_path curr_files='' new_file_list='' new_exec_files='' \
		md5sum_present='' dist_dir main_file_path frontend_updated='' \
		upper_dist_dir="$1" components="$2" upd_channel="$3"

	for component in $components; do
		eval "version=\"\${ref_${component}}\""
		[ -n "$version" ] || { inst_failed "Internal error: failed to get version for component '$component'."; return 1; }
		dist_dir="${upper_dist_dir}/${component}"

		log_msg "" "Installing new $component files..."

		# read new files list
		read -r new_file_list < "${dist_dir}/new_file_list" && [ -n "$new_file_list" ] &&
		read -r new_exec_files < "${dist_dir}/exec_files" ||
			{
				rm -f "${dist_dir}/new_file_list" "${dist_dir}/exec_files"
				inst_failed "Failed to read new file list."
				return 1
			}
		rm -f "${dist_dir}/new_file_list" "${dist_dir}/exec_files"

		# replace newlines with whitespaces
		new_file_list="${new_file_list//"$_NL_"/ }"

		# get current files list
		get_file_list curr_files "$component" ALL || return 1

		# get timestamp of the main file for component
		eval "main_file_path=\"\${QOSMATE_MAIN_FILE_${component}}\""
		local old_main_timestamp='' new_timestamp
		[ -f "$main_file_path" ] && {
			old_main_timestamp="$(get_file_timestamp "$main_file_path")" || { inst_failed; return 1; }
		}

		# version and update channel string replacement vars
		local ver_ptrn_prefix ver_repl_str upd_ch_repl_str
		case "$component" in
			BACKEND)
				ver_ptrn_prefix=
				ver_repl_str="VERSION\=\"$version\""
				upd_ch_repl_str="UPD_CHANNEL\=\"$upd_channel\"" ;;
			FRONTEND)
				ver_ptrn_prefix="const UI_"
				ver_repl_str="VERSION \= '$version'\;"
				upd_ch_repl_str="UPD_CHANNEL \= '$upd_channel'\;" ;;
		esac

		# check if old component installation has the new update format
		local old_install_has_new_format=''
		[ -f "$main_file_path" ] && grep -q "^${ver_ptrn_prefix}${upd_ch_repl_str}" "$main_file_path" &&
			old_install_has_new_format=1

		# set version and update channel in component's main file
		local preinst_main_file_path
		if [ "$component" = FRONTEND ]; then
			fixup_frontend_path preinst_main_file_path "$dist_dir" "$main_file_path" || return 1
		else
			preinst_main_file_path="${dist_dir}/${main_file_path}"
		fi

		sed -i "
			/^\s*${ver_ptrn_prefix}VERSION\s*=/{s/.*/${ver_ptrn_prefix}${ver_repl_str}/;}
			/^\s*${ver_ptrn_prefix}UPD_CHANNEL\s*=/{s/.*/${ver_ptrn_prefix}${upd_ch_repl_str}/;}" \
				"$preinst_main_file_path" &&
					# verify that substitution worked
					grep -q "^${ver_ptrn_prefix}${ver_repl_str}" "$preinst_main_file_path" &&
					grep -q "^${ver_ptrn_prefix}${upd_ch_repl_str}" "$preinst_main_file_path" ||
						{ inst_failed "Failed to set version in file '$preinst_main_file_path'."; return 1; }

		# Copy changed files
		check_util md5sum && md5sum_present=1
		new_timestamp="$(get_file_timestamp "$preinst_main_file_path")" || { inst_failed; return 1; }
		local file_timestamp mod_files_bk_dir="/tmp/qosmate_old_modified_files"
		for file in $new_file_list
		do
			if [ "$component" = FRONTEND ]; then
				fixup_frontend_path preinst_path "$dist_dir" "$file"
			else
				preinst_path="${dist_dir}${file}"
			fi

			if [ -f "$file" ] && [ -n "$md5sum_present" ] &&
				md5sum "$preinst_path" "$file" | awk 'BEGIN{rv=1} {if ($1 in seen) {rv=0; next}; seen[$1]} END{exit rv}'
			then
				log_msg "File '$file' did not change - not updating."
			else
				# Check for manually modified files and create a backup copy if needed
				if [ -n "$old_install_has_new_format" ] && [ -n "$old_main_timestamp" ] &&
					file_timestamp="$(get_file_timestamp "$file")" &&
					[ "$file_timestamp" != "$old_main_timestamp" ] ; then
						log_msg -warn "Timestamp of file '$file' doesn't match the main $component timestamp."
						if try_mkdir -p "$mod_files_bk_dir" && cp "$file" "${mod_files_bk_dir}/${file##*/}"; then
							log_msg "Saved a backup copy of manually modified file to ${mod_files_bk_dir}/${file##*/}"
						else
							log_msg -warn "Can not create a backup copy of manually modified file '$file' - overwriting anyway."
						fi
				fi

				log_msg "Copying file '${file}'."
				{ [ -d "${file%/*}" ] || try_mkdir -p "${file%/*}"; } &&
				cp "$preinst_path" "$file" ||
					{ inst_failed "Failed to copy file '$preinst_path' to '$file'."; return 1; }
				[ "$component" = FRONTEND ] && frontend_updated=1
			fi

			# set new timestamp
			touch -d "$new_timestamp" "$file" || { inst_failed "Failed to set timestamp for file '$file'."; return 1; }
		done

		# delete obsolete files
		for file in ${curr_files}
		do
			[ -f "$file" ] || continue

			# check for $file in $new_file_list, allowing whitespaces and tabs as list delimiter
			case "$new_file_list" in
				"$file"|"$file"[\ \	]*|*[\ \	]"$file"|*[\ \	]"$file"[\ \	]*)
					continue ;;
				*)
					log_msg "Deleting obsolete file $file."
					rm -f "$file"
			esac
		done

		chmod +x $new_exec_files || { inst_failed "Failed to make files '$new_exec_files' executable."; return 1; }
	done

    # Restart rpcd only if any frontend files were updated
    [ -n "$frontend_updated" ] && /etc/init.d/rpcd restart
	:
}


### Servce functions

# sync all files timestamps to main component file's timestamp
# 1 - component: <BACKEND|FRONTEND>
sync_timestamps() {
	local timestamp file files file_types main_file_path component="$1"
	eval "main_file_path=\"\${QOSMATE_MAIN_FILE_${component}}\""

	timestamp="$(get_file_timestamp "$main_file_path")" || return 1

	files=
	eval "file_types=\"\${QOSMATE_FILE_TYPES_${component}}\""
	get_file_list files "$component" ALL && [ -n "$files" ] ||
		{ error_out "Failed to get file list for component '$component'."; return 1; }
	
	for file in $files; do
		[ -f "$file" ] || { error_out "Missing file: '$file'."; return 1; }
		touch -d "$timestamp" "$file" || { error_out "Failed to set timestamp for file '$file'"; return 1; }
	done
}

load_config() {
    config_load 'qosmate'
    config_get WAN settings 'WAN' 'eth1'
}

validate_custom_rules() {
    local tmp_file="/tmp/qosmate_custom_rules_validation.txt"
    local rules_file="/etc/qosmate.d/custom_rules.nft"

    if [ ! -f "$rules_file" ]; then
        echo "Custom rules file not found." | tee "$tmp_file"
        return 1
    fi

    nft_output=$(nft --check --file "$rules_file" 2>&1)
    nft_exit_code=$?

    echo "$nft_output" | tee "$tmp_file"

    if [ $nft_exit_code -eq 0 ]; then
        echo "Custom rules validation successful." | tee -a "$tmp_file"
        return 0
    else
        echo "Custom rules validation failed." | tee -a "$tmp_file"
        return 1
    fi
}

# Detect package manager (opkg or apk)
detect_package_manager() {
    local has_apk=0 has_opkg=0
    
    command -v apk >/dev/null 2>&1 && has_apk=1
    command -v opkg >/dev/null 2>&1 && has_opkg=1
    
    if [ $has_apk -eq 1 ] && [ $has_opkg -eq 1 ]; then
        echo "conflict"
    elif [ $has_apk -eq 1 ]; then
        echo "apk"
    elif [ $has_opkg -eq 1 ]; then
        echo "opkg"
    else 
        echo "unknown"
    fi
}

# Check for valid package manager
check_pkg_manager() {
    case "$1" in
        apk|opkg)
            return 0
            ;;
        conflict)
            logger -s -t qosmate -p user.err "Multiple package managers detected (apk and opkg). Package management disabled."
            return 1
            ;;
        *)
            logger -s -t qosmate -p user.err "Error: No supported package manager found."
            return 1
            ;;
    esac
}

# Check if a package is installed
check_package() {
    local pkg="$1"
    
    case "$pkg_manager" in
        "apk")
            apk list -I "$pkg" 2>/dev/null | grep -q "^$pkg-[0-9]"
            return $?
            ;;
        "opkg")
            opkg list-installed | grep -q "^$pkg "
            return $?
            ;;
        *)
            return 1
            ;;
    esac
}

install_packages() {
    # Flag to indicate if opkg update is needed    
    local need_update=0

    check_pkg_manager "$pkg_manager" || return 1

    # Check if any packages are missing
    for pkg in $REQUIRED_PACKAGES; do
        if ! check_package "$pkg"; then
            echo "$pkg is not installed."
            need_update=1
            break
        fi
    done

    # Run update if at least one package is missing
    if [ "$need_update" -eq 1 ]; then
        echo "Updating package list..."
        case "$pkg_manager" in
            "apk")
                apk update
                ;;
            "opkg")
                opkg update
                ;;
        esac

        # Install missing packages
        for pkg in $REQUIRED_PACKAGES; do
            if ! check_package "$pkg"; then
                echo "Installing $pkg..."
                logger -t qosmate "Installing $pkg..."
                case "$pkg_manager" in
                    "apk")
                        apk add "$pkg" || {
                            echo "Failed to install $pkg."
                            logger -t qosmate "Failed to install $pkg."
                            return 1  # Abort if the installation fails
                        }
                        ;;
                    "opkg")
                        opkg install "$pkg" || {
                            echo "Failed to install $pkg."
                            logger -t qosmate "Failed to install $pkg."
                            return 1  # Abort if the installation fails
                        }
                        ;;
                esac
            fi
        done
    fi
}

check_package_status() {
    local missing_packages=""
    
    for pkg in $REQUIRED_PACKAGES; do
        if ! check_package "$pkg"; then
            missing_packages="$missing_packages $pkg"
        fi
    done
    
    if [ -n "$missing_packages" ]; then
        echo "Missing packages:$missing_packages"
        logger -t qosmate "Missing packages:$missing_packages"
        return 1
    fi
    return 0
}

create_hotplug_script() {
    cat > /etc/hotplug.d/iface/13-qosmateHotplug << 'EOF'
#!/bin/sh

[ -n "$DEVICE" ] || exit 0
if [ "$ACTION" = ifup ]; then
    . /lib/functions.sh
    config_load qosmate || {
        logger -t qosmate -p user.err "Failed to load config."
        exit 1
    }
    config_get qosmate_enabled global enabled
    if [ "$qosmate_enabled" = "1" ]; then
        logger -t qosmate "Reloading qosmate.sh due to $ACTION of $INTERFACE ($DEVICE)"
        /etc/init.d/qosmate enable
        /etc/init.d/qosmate restart
    else
        logger -t qosmate "qosmate is disabled in the configuration. Not executing the script."
    fi
fi
EOF
}

check_and_download_config() {
    local config_path="/etc/config/qosmate"
    if [ ! -f "$config_path" ]; then
        echo "Configuration file not found, downloading the latest version..."
        wget -O $config_path "$QOSMATE_BASE_URL/etc/config/qosmate" || {
            echo "Error downloading configuration. Please check your internet connection and try again."
            return 1
        }
        echo "Configuration file downloaded successfully."
    else
        echo "Configuration file already exists."
    fi
}

migrate_config() {
    CONFIG_FILE="/etc/config/qosmate"

    # Function to add the global enabled option if it does not exist
    if ! grep -q "config global 'global'" $CONFIG_FILE; then
        echo "Adding global configuration section..."
        sed -i '1i\
config global '\''global'\''\n    option enabled '\''1'\''\n' $CONFIG_FILE
        echo "Global configuration section added."
    else
        echo "Global configuration section already exists."
    fi

    # Ensure the enabled option is present in the global section
    if ! grep -q "option enabled" $CONFIG_FILE; then
        echo "Adding enabled option to global section..."
        sed -i "/config global 'global'/a\\
    option enabled '1'
" $CONFIG_FILE
        echo "Enabled option added."
    else
        echo "Enabled option already exists."
    fi

    # Check for and correct the custom_rules section
    if grep -q "config qosmate 'custom_rules'" $CONFIG_FILE; then
        echo "Incorrect custom_rules section found. Correcting..."
        sed -i "s/config qosmate 'custom_rules'/config custom_rules 'custom_rules'/" $CONFIG_FILE
        echo "custom_rules section corrected."
    fi

    # Remove duplicate custom_rules sections if both incorrect and correct versions exist
    if grep -q "config qosmate 'custom_rules'" $CONFIG_FILE && grep -q "config custom_rules 'custom_rules'" $CONFIG_FILE; then
        echo "Both incorrect and correct custom_rules sections found. Removing the incorrect one..."
        sed -i "/config qosmate 'custom_rules'/d" $CONFIG_FILE
        echo "Incorrect custom_rules section removed."
    fi
}

manage_custom_rules_file() {
    local action="$1"
    
    case "$action" in
        create)
            # Ensure the directory exists
            [ ! -d "/etc/qosmate.d" ] && mkdir -p "/etc/qosmate.d"
            
            # Create the file if it doesn't exist
            [ ! -f "/etc/qosmate.d/custom_rules.nft" ] && touch "/etc/qosmate.d/custom_rules.nft"

            ;;
        delete)
            # Not used at the moment...
            rm -f "/etc/qosmate.d/custom_rules.nft"
            ;;
    esac
}

start_service() {
	check_files_integrity BACKEND
	case $? in
		0) ;; # integrity OK
		1) return 1 ;;
		2) # missing files
			update -n -v "$UPD_CHANNEL" -c BACKEND || return 1 ;;
		3) ;; # non-matching timestamps
	esac
    install_packages
    create_hotplug_script  # Create the hotplug script instead of downloading it
    check_and_download_config || return 1
    migrate_config

    # Enable the global option
    uci set qosmate.global.enabled='1'
    uci commit qosmate

    # Save the current WAN interface to a temporary file
    load_config
    echo "$WAN" > /tmp/qosmate_wan

    # Create custom rules file if it doesn't exist
    manage_custom_rules_file create
    nft delete table inet qosmate_custom 2>/dev/null
    nft -f /etc/qosmate.d/custom_rules.nft

    /etc/qosmate.sh
    /etc/init.d/firewall reload
    logger -t qosmate "Service started"
    /etc/init.d/qosmate enable
}

stop_service() {
    # Read the old WAN interface from the temporary file
    OLD_WAN=$(cat /tmp/qosmate_wan 2>/dev/null)
    if [ -z "$OLD_WAN" ]; then
        # If the temporary file doesn't exist, fall back to WAN from config
        load_config
        OLD_WAN="$WAN"
    fi

    echo "Stopping service qosmate..."
    
    # Only disable if not in shutdown and not in restart
    if [ "$DISABLE_ON_STOP" != "0" ] && [ -z "$FROM_SHUTDOWN" ]; then
        /etc/init.d/qosmate disable
        uci set qosmate.global.enabled='0'
        uci commit qosmate
    fi

    # Remove custom rules table
    nft delete table inet qosmate_custom 2>/dev/null

    ## Delete files
    rm -f /etc/hotplug.d/iface/13-qosmateHotplug
    rm -f /usr/share/nftables.d/ruleset-post/dscptag.nft

    ## Delete the old qdiscs and IFB associated with the old WAN interface
    tc qdisc del dev "$OLD_WAN" root > /dev/null 2>&1
    tc qdisc del dev ifb-"$OLD_WAN" root > /dev/null 2>&1
    tc qdisc del dev "$OLD_WAN" ingress > /dev/null 2>&1

    # Remove IFB interface
    ip link del ifb-"$OLD_WAN" 2>/dev/null

    nft delete table inet dscptag

    # Remove the temporary file
    rm -f /tmp/qosmate_wan

    echo "Reloading network service..."
    /etc/init.d/network reload
    /etc/init.d/firewall reload
    logger -t qosmate "Service stopped"
    exit 0
}

shutdown() {
    # Set variable for shutdown
    FROM_SHUTDOWN=1
    # Call stop_service
    stop_service
}

status_service() {
    # Load configuration
    config_load 'qosmate'

    # Function to extract default values from the main script
    get_default_value() {
        local var_name="$1"
        grep "^$var_name=" /etc/qosmate.sh | cut -d'=' -f2- | tr -d '"'
    }

    # Get current values, replace with defaults if not set
    local WAN UPRATE DOWNRATE GAMEUP GAMEDOWN gameqdisc
    config_get WAN settings WAN
    : "${WAN:="$(get_default_value DEFAULT_WAN)"}"
    config_get UPRATE settings UPRATE
    : "${UPRATE:="$(get_default_value DEFAULT_UPRATE)"}"
    config_get DOWNRATE settings DOWNRATE
    : "${DOWNRATE:="$(get_default_value DEFAULT_DOWNRATE)"}"

    config_get ROOT_QDISC settings ROOT_QDISC "hfsc"
    config_get gameqdisc hfsc gameqdisc
    : "${gameqdisc:="$(get_default_value DEFAULT_GAMEQDISC)"}"

    # For default GAMEUP and GAMEDOWN, we need to evaluate the expressions
    config_get GAMEUP hfsc GAMEUP
    : "${GAMEUP:=$((UPRATE*15/100+400))}"
    config_get GAMEDOWN hfsc GAMEDOWN
    : "${GAMEDOWN:=$((DOWNRATE*15/100+400))}"

    echo "==== qosmate Status ===="
    
    # Check if autostart is enabled
    if /etc/init.d/qosmate enabled; then
        echo "qosmate autostart is enabled."
    else
        echo "qosmate autostart is not enabled."
    fi

    # Check if the service is enabled in UCI config
    if [ "$(uci -q get qosmate.global.enabled)" = "1" ]; then
        echo "qosmate service is enabled."
    else
        echo "qosmate service is disabled."
    fi

    # Check if traffic shaping is active
    local IFB="ifb-$WAN"
    
    if tc qdisc show dev "$WAN" 2>/dev/null | grep -q "qdisc cake"; then
        if [ "$(uci -q get qosmate.global.enabled)" = "1" ]; then
            echo "Traffic shaping is active on the egress interface ($WAN)."
        else
            echo "Default CAKE qdisc is active on the egress interface ($WAN), but qosmate is not managing it."
        fi
    elif tc qdisc show dev "$WAN" 2>/dev/null | grep -q "qdisc hfsc"; then
        echo "Traffic shaping (HFSC) is active on the egress interface ($WAN)."
    else
        echo "No traffic shaping is active on the egress interface ($WAN)."
    fi

    if tc qdisc show dev "$IFB" 2>/dev/null | grep -q "qdisc cake\|qdisc hfsc"; then
        echo "Traffic shaping is active on the ingress interface ($IFB)."
    else
        echo "No traffic shaping is active on the ingress interface ($IFB)."
    fi

    echo "==== Overall Status ===="
    # Determine if the service is actually running
    if [ "$(uci -q get qosmate.global.enabled)" = "1" ] && { tc qdisc show dev "$WAN" 2>/dev/null | grep -q "qdisc hfsc" ||
            tc qdisc show dev "$IFB" 2>/dev/null | grep -q "qdisc cake\|qdisc hfsc"; }; then
            echo "qosmate is currently active and managing traffic shaping."
    else
        echo "qosmate is not currently active or managing traffic shaping."
    fi

    echo "==== Current Settings ===="
    # Show summary of current settings
    echo "Upload rate: $UPRATE kbps"
    echo "Download rate: $DOWNRATE kbps"
    
    echo "Game traffic upload: $GAMEUP kbps"
    echo "Game traffic download: $GAMEDOWN kbps"
    if [ "$ROOT_QDISC" = "cake" ]; then
        echo "Queue discipline: CAKE (Root qdisc)"
    else
        echo "Queue discipline: $gameqdisc (for game traffic in HFSC)"
    fi

    echo "==== Package Status ===="

    if check_pkg_manager "$pkg_manager" && check_package_status; then
        echo "All required packages are installed."
    else
        echo "Some required packages are missing. QoSmate may not function correctly."
    fi

    echo
    echo "==== Detailed Technical Information ===="
    echo "Traffic Control (tc) Queues:"
    tc -s qdisc

    echo
    echo "==== Nftables Ruleset (dscptag) ===="
    nft list ruleset | grep 'chain dscptag' -A 100


    echo
    echo "==== Custom Rules Table Status ===="
    if nft list table inet qosmate_custom &>/dev/null; then
        echo "Custom rules table (qosmate_custom) is active."
        echo "Current custom rules:"
        nft list table inet qosmate_custom
    else
        echo "Custom rules table (qosmate_custom) is not active or doesn't exist."
    fi

}

restart() {
    DISABLE_ON_STOP=0 /etc/init.d/qosmate stop
    sleep 1 # Ensure all processes have been properly terminated
    /etc/init.d/qosmate start    
}

reload_service() {
    restart
}

# 1 - speedtest command
# 2 - Upload|Download
# I/O via STDIN/STDOUT
parse_speedtest_output() {
    local speedtest_cmd="$1" direction="$2"
    case "$speedtest_cmd" in
        speedtest-go*)
            grep "${direction}:" | grep -oE '[0-9]+\.[0-9]+' | head -n1
            ;;
        "speedtest --simple"*)
            # match to (Upload:|Download:).*, print field 2. if no match, return 1
            awk "BEGIN{rv=1} \$0~/$direction:/ {print \$2; rv=0; exit} END{exit rv}"
            ;;
        *)
            echo "Unexpected speedtest command '$speedtest_cmd'." >&2
            false
            ;;
    esac || {
        echo "Failed to get the $direction speed." >&2
        echo "0"
        return 1
    }
    :
}

# for non-interactive setup, call with '-n [gaming_ip_address]'
auto_setup() {
    local L3_DEVICE WAN_INTERFACE FINAL_INTERFACE SPEEDTEST_CMD FREE_SPACE SPEED_RESULT DOWNLOAD_SPEED UPLOAD_SPEED
    local gaming_ip='' noninteractive='' speed_choice response speedtest_req direction

    if [ "$1" = "-n" ]; then
        gaming_ip="$2"
        noninteractive=1
    else
        noninteractive=
    fi
    [ -z "$noninteractive" ] && echo "Starting qosmate auto-setup..."

    # Stop qosmate if it's running
    if /etc/init.d/qosmate status > /dev/null; then
        echo "Stopping qosmate for accurate speed test results..."
        /etc/init.d/qosmate stop
        sleep 5  # Give some time for the network to stabilize
    fi

    # Detect WAN interface
    WAN_INTERFACE=$(ifstatus wan | grep -e '"device"' | cut -d'"' -f4)
    L3_DEVICE=$(ifstatus wan | grep -e '"l3_device"' | cut -d'"' -f4)

    if [ -z "$WAN_INTERFACE" ] && [ -z "$L3_DEVICE" ]; then
        echo "Error: Unable to detect WAN interface. Please set it manually in the configuration."
        return 1
    fi

    FINAL_INTERFACE=${L3_DEVICE:-$WAN_INTERFACE}
    echo "Detected WAN interface: $FINAL_INTERFACE"

    if [ -n "$noninteractive" ]; then
        speedtest_req=1
    else
        while :; do
            echo "Do you want to run a speed test or enter speeds manually? [test/manual]"
            read -r speed_choice
            case "$speed_choice" in
                *[A-Z]*) speed_choice="$(printf %s "$speed_choice" | tr 'A-Z' 'a-z')"
            esac

            case "$speed_choice" in
                test|manual) break
            esac
            echo "Invalid input '$speed_choice'. Please enter 'test' or 'manual'."
        done

        if [[ "$speed_choice" = manual ]]; then
            for direction in download upload; do
                while :; do
                    echo "Please enter your $direction speed in Mbit/s:"
                    read -r response
                    case "$response" in
                        ''|*[!0-9.]*|*.*.*)
                            # do not allow empty string or irrelevant characters or 2x '.'
                            echo "Invalid input '$response'. Please try again."
                            continue
                            ;;
                        *[0-9]*)
                            break
                            ;;
                        *)
                            # do not allow input without digits
                            echo "Invalid input '$response'. Please try again."
                            continue
                            ;;
                    esac
                done
                case "$direction" in
                    download) DOWNLOAD_SPEED="$response" ;;
                    upload) UPLOAD_SPEED="$response" ;;
                esac
            done
            speedtest_req=
        else
            echo "This will run a speed test to configure qosmate. Do you want to continue? [y/N]"
            read -r response
            if [[ ! "$response" =~ ^[Yy]$ ]]; then
                echo "Auto-setup cancelled."
                return 0
            fi
            speedtest_req=1
        fi
    fi

    if [ -n "$speedtest_req" ]; then
        # Check for speedtest-go first
        if command -v speedtest-go &> /dev/null; then
            echo "speedtest-go is already installed. Using it for the speed test."
            SPEEDTEST_CMD="speedtest-go"
        else
            echo "speedtest-go is not found. Checking for python3-speedtest-cli..."
            if command -v speedtest &> /dev/null; then
                echo "python3-speedtest-cli is already installed. Using it for the speed test."
                SPEEDTEST_CMD="speedtest --simple"
            else
                echo "Neither speedtest-go nor python3-speedtest-cli is installed. Attempting to install speedtest-go..."
                check_pkg_manager "$pkg_manager" || return 1
                
                # Check for sufficient space (adjust the required space as needed)
                FREE_SPACE=$(df /overlay | awk 'NR==2 {print $4}')
                if [ "$FREE_SPACE" -lt 15360 ]; then  # Assuming 15MB for speedtest-go
                    echo "Not enough space for speedtest-go. Attempting to install python3-speedtest-cli instead..."
                else
                    case "$pkg_manager" in
                        "apk")
                            apk update && apk add speedtest-go
                            ;;
                        "opkg")
                            opkg update && opkg install speedtest-go
                            ;;
                    esac
                    if [ $? -eq 0 ]; then
                        SPEEDTEST_CMD="speedtest-go"
                    else
                        echo "Failed to install speedtest-go. Attempting to install python3-speedtest-cli instead..."
                    fi
                fi

                # If speedtest-go installation failed or there wasn't enough space, try python3-speedtest-cli
                if [ -z "$SPEEDTEST_CMD" ]; then
                    if [ "$FREE_SPACE" -lt 1024 ]; then  # 1MB for python3-speedtest-cli
                        echo "Error: Not enough free space to install any speedtest tool."
                        echo "Auto-setup cannot continue. Please free up some space and try again."
                        return 1
                    fi
                    case "$pkg_manager" in
                        "apk")
                            apk update && apk add python3-speedtest-cli
                            ;;
                        "opkg")
                            opkg update && opkg install python3-speedtest-cli python3-speedtest-cli-src
                            ;;
                    esac
                    if [ $? -eq 0 ]; then
                        SPEEDTEST_CMD="speedtest --simple"
                    else
                        echo "Failed to install python3-speedtest-cli. Auto-setup cannot continue."
                        return 1
                    fi
                fi
            fi
        fi

        echo "Running speed test... This may take a few minutes."
        SPEED_RESULT=$($SPEEDTEST_CMD)

        DOWNLOAD_SPEED=$(printf %s "$SPEED_RESULT" | parse_speedtest_output "$SPEEDTEST_CMD" Download) &&
        UPLOAD_SPEED=$(printf %s "$SPEED_RESULT" | parse_speedtest_output "$SPEEDTEST_CMD" Upload) ||
            return 1

        echo "Speed test results:"
        echo "Download speed: $DOWNLOAD_SPEED Mbit/s"
        echo "Upload speed: $UPLOAD_SPEED Mbit/s"
    fi

    # Convert speeds to kbps and apply 90% rule
    DOWNRATE=$(awk -v speed="$DOWNLOAD_SPEED" 'BEGIN {print int(speed * 1000 * 0.9)}')
    UPRATE=$(awk -v speed="$UPLOAD_SPEED" 'BEGIN {print int(speed * 1000 * 0.9)}')

    echo "QoS configuration:"
    echo "DOWNRATE: $DOWNRATE kbps (90% of measured download speed)"
    echo "UPRATE: $UPRATE kbps (90% of measured upload speed)"

    # Section for gaming device IP
    if [ -z "$noninteractive" ]; then
        echo "Would you like to add a gaming device IP for prioritization? [y/N]"
        read -r response
        if [[ "$response" =~ ^[Yy]$ ]]; then
            echo "Please enter the IP address of your gaming device:"
            read -r gaming_ip
        fi
    fi

    if [ -n "$gaming_ip" ]; then
        # Validate IP address format
        if [[ $gaming_ip =~ ^[0-9]{1,3}\.[0-9]{1,3}\.[0-9]{1,3}\.[0-9]{1,3}$ ]]; then
            # Check if rules for this IP already exist
            if grep -q "option src_ip '$gaming_ip'" /etc/config/qosmate || grep -q "option dest_ip '$gaming_ip'" /etc/config/qosmate; then
                echo "Rules for IP $gaming_ip already exist. Skipping addition of new rules."
                gaming_ip=
            fi
        else
            echo "Invalid IP address format. No gaming device rules added."
            gaming_ip=
        fi
    fi

    local temp_config_file="/tmp/qosmate_config.tmp"
    if [ -f /etc/config/qosmate ]; then
        cp /etc/config/qosmate "$temp_config_file"
    else
        echo "Error: config file '/etc/config/qosmate' not found."
        return 1
    fi

    # TODO: all of this should be rewritten with UCI commands
    sed -i "/option WAN/c\    option WAN '$FINAL_INTERFACE'
        /option DOWNRATE/c\    option DOWNRATE '$DOWNRATE'
        /option UPRATE/c\    option UPRATE '$UPRATE'" \
            "$temp_config_file" &&
    if [ -n "$gaming_ip" ] && cat << EOF >> "$temp_config_file"
config rule
    option name 'Game_Console_Outbound'
    option proto 'udp'
    option src_ip '$gaming_ip'
    list dest_port '!=80'
    list dest_port '!=443'
    option class 'cs5'
    option counter '1'

config rule
    option name 'Game_Console_Inbound'
    option proto 'udp'
    option dest_ip '$gaming_ip'
    list src_port '!=80'
    list src_port '!=443'
    option class 'cs5'
    option counter '1'
EOF
    then
        echo "Gaming device rules added for IP: $gaming_ip"
        :
    else
        echo "No gaming device IP added."
        :
    fi &&
    mv "$temp_config_file" /etc/config/qosmate ||
    {
        echo "Failed to modify the config. Please check the file /etc/config/qosmate" >&2
        return 1
    }

    echo "Configuration updated. New settings:"
    grep -E "option (WAN|DOWNRATE|UPRATE)" /etc/config/qosmate


    echo "Auto-setup complete. qosmate has been configured with detected settings."
    echo "To apply these changes, please restart qosmate by running: /etc/init.d/qosmate restart"
}

auto_setup_noninteractive() {
    local output_file="/tmp/qosmate_auto_setup_output.txt" auto_setup_rv
    {
        echo "Starting qosmate non-interactive auto-setup..."
        auto_setup -n "$1" 2>&1
    } > "$output_file"
    auto_setup_rv=$?
    echo "$output_file"
    return $auto_setup_rv
}

expand_config() {
    local config_file="/etc/config/qosmate"
    local main_script="/etc/qosmate.sh"
    
    log_msg "" "Expanding qosmate configuration with all possible options..."

    # Ensure all sections exist
    for section in global settings advanced hfsc cake custom_rules; do
        if ! grep -q "config $section '$section'" "$config_file"; then
            echo >> "$config_file"  # Add a newline before the new section
            echo "config $section '$section'" >> "$config_file"
            echo "Added section: $section"
        fi
    done

    # Function to get default value from main script
    get_default_value() {
        local option="$1"
        local default_value

        # Map options to their DEFAULT_ counterparts
        case "$option" in
            OH) option="DEFAULT_OH" ;;
            WAN) option="DEFAULT_WAN" ;;
            DOWNRATE) option="DEFAULT_DOWNRATE" ;;
            UPRATE) option="DEFAULT_UPRATE" ;;
        esac

        # First, try to find a direct assignment
        default_value=$(grep "^${option}=" "$main_script" | cut -d'=' -f2- | tr -d '"')

        # If not found, look for it in the load_config function
        if [ -z "$default_value" ]; then
            default_value=$(sed -n "/load_config()/,/}/p" "$main_script" | grep "\<${option}=" | sed 's/.*|| echo "\(.*\)".*/\1/')
        fi

        # Remove any remaining shell expansions and trim whitespace
        default_value=$(echo "$default_value" | sed -e 's/\$([^)]*)//g' -e 's/^ *//g' -e 's/ *$//g' -e 's/\${{.*}}//g')

        # Check for dynamic calculations and return empty string if found
        if echo "$default_value" | grep -qE '[[($]|\)$'; then
            echo ""
        else
            echo "$default_value"
        fi
    }
    # Define options for each section
    add_options() {
        local section="$1"
        shift
        for option in "$@"; do
            if ! grep -q "option $option" "$config_file"; then
                default_value=$(get_default_value "$option")
                sed -i "/config $section/a\\    option $option '$default_value'" "$config_file"
                echo "Added option $option to section $section with value: $default_value"
            fi
        done
    }

    # Add options for each section
    add_options global enabled
    add_options settings WAN DOWNRATE UPRATE ROOT_QDISC
    add_options advanced PRESERVE_CONFIG_FILES WASHDSCPUP WASHDSCPDOWN BWMAXRATIO ACKRATE UDP_RATE_LIMIT_ENABLED UDPBULKPORT TCPBULKPORT VIDCONFPORTS REALTIME4 REALTIME6 LOWPRIOLAN4 LOWPRIOLAN6 TCP_UPGRADE_ENABLED MSS NFT_HOOK NFT_PRIORITY
    add_options hfsc LINKTYPE OH gameqdisc GAMEUP GAMEDOWN nongameqdisc nongameqdiscoptions MAXDEL PFIFOMIN PACKETSIZE netemdelayms netemjitterms netemdist pktlossp
    add_options cake COMMON_LINK_PRESETS OVERHEAD MPU LINK_COMPENSATION ETHER_VLAN_KEYWORD PRIORITY_QUEUE_INGRESS PRIORITY_QUEUE_EGRESS HOST_ISOLATION NAT_INGRESS NAT_EGRESS ACK_FILTER_EGRESS RTT AUTORATE_INGRESS EXTRA_PARAMETERS_INGRESS EXTRA_PARAMETERS_EGRESS

    echo "Configuration expanded successfully. You can now edit all available options in $config_file"
}

health_check() {
    # Check if QoSmate is properly configured and running
    local status=""
    local errors=0

    # Check files existence and timestamps
	for component in ${QOSMATE_COMPONENTS}; do
		if check_files_integrity "$component"; then
			status="${status}${component}_integrity:ok;"
		else
			status="${status}${component}_integrity:failed;"
			errors=$((errors + 1))
		fi
	done

    load_config
    
    # Check if the service is enabled
    if /etc/init.d/qosmate enabled; then
        status="${status}service:enabled;"
    else
        status="${status}service:disabled;"
        errors=$((errors + 1))
    fi
    
    # Check nftables configuration
    if nft list table inet dscptag >/dev/null 2>&1; then
        status="${status}nft:ok;"
    else
        status="${status}nft:failed;"
        errors=$((errors + 1))
    fi
    
    # Check tc configuration on WAN interface
    if [ -n "$WAN" ] && tc qdisc show dev "$WAN" 2>/dev/null | grep -E -q "hfsc|cake"; then
        status="${status}tc:ok;"
    else
        status="${status}tc:failed;"
        errors=$((errors + 1))
    fi
    
    # Check if essential config file exists
    if [ -f "/etc/config/qosmate" ]; then
        status="${status}config:ok;"
    else
        status="${status}config:missing;"
        errors=$((errors + 1))
    fi
    
    # Check required packages
    local missing_packages=""
    for pkg in $REQUIRED_PACKAGES; do
        if ! check_package "$pkg"; then
            missing_packages="${missing_packages}${pkg} "
        fi
    done
    
    if [ -z "$missing_packages" ]; then
        status="${status}packages:ok;"
    else
        status="${status}packages:missing:${missing_packages};"
        errors=$((errors + 1))
    fi
    
    # Output status
    echo "status=$status;errors=$errors"
    
    # Return code depending on errors
    [ $errors -eq 0 ] || return 1
    return 0
}

pkg_manager="$(detect_package_manager)" # global variable


### Process command-line args

# if called directrly via /bin/sh with one of the keywords, set $action to the keyword
case "$1" in
	update|print_file_list|post_update_1|post_update_2) action="$1"; shift
esac

case "$action" in
	update|print_file_list|post_update_1|post_update_2) "$action" "$@"; exit $? ;;
esac

:
